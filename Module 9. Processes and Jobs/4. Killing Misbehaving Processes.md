# Killing Misbehaving Processes
kill command

## My solve
**Flag:** `pwn.college{YRXPGMeVF0anLOFeJkQuOwczIlY.0FNzMDOxwCN1gjNzEzW}`

We identified and terminated a misbehaving decoy process that was spamming a named pipe with fake data. This cleared the communication channel, allowing the real program to run and for us to read the correct flag

```bash
hacker@processes~killing-misbehaving-processes:~$ ps aux | grep decoy
root         139  0.0  0.0   5204  3520 ?        S    18:42   0:00 su -c exec /challenge/decoy > /tmp/flag_fifo hacker
hacker       142  0.2  0.0  13516  9280 ?        Ss   18:42   0:00 /usr/bin/python /challenge/decoy
hacker       361  0.0  0.0 230700  2560 pts/0    S+   18:42   0:00 grep --color=auto decoy
hacker@processes~killing-misbehaving-processes:~$ kill 142
hacker@processes~killing-misbehaving-processes:~$ /challenge/run
Sending the flag to /tmp/flag_fifo!
hacker@processes~killing-misbehaving-processes:~$ cat /tmp/flag_fifo
pwn.college{YRXPGMeVF0anLOFeJkQuOwczIlY.0FNzMDOxwCN1gjNzEzW}
```

## What i learned
we learned how to use ps aux to find and terminate specific processes we own, bypassing the limitations of the basic ps command. we also saw a practical example of I/O buffering, where a pipe continues to output data even after the process feeding it has been killed

# Refrences
online documentation on ps