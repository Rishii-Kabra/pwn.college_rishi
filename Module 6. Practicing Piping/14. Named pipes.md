# Named pipes
FIFOs

## My solve
**Flag:** `pwn.college{4K3xxpKDGB8dVi0T-Tn7mHpli99.01MzMDOxwCN1gjNzEzW}`

we first create a file using FIFO. we then redirect the stdout to it and simultaneously ready the read side of the pipe for proper functioning

```bash
hacker@piping~named-pipes:~$ mkfifo /tmp/flag_fifo
hacker@piping~named-pipes:~$ /challenge/run > /tmp/flag_fifo
You're successfully redirecting /challenge/run to a FIFO at /tmp/flag_fifo! 
Bash will now try to open the FIFO for writing, to pass it as the stdout of 
/challenge/run. Recall that operations on FIFOs will *block* until both the 
read side and the write side is open, so /challenge/run will not actually be 
launched until you start reading from the FIFO!
hacker@piping~named-pipes:~$ cat /tmp/flag_fifo
You've correctly redirected /challenge/run's stdout to a FIFO at 
/tmp/flag_fifo! Here is your flag:
pwn.college{4K3xxpKDGB8dVi0T-Tn7mHpli99.01MzMDOxwCN1gjNzEzW}
```

## What i learned
FIFOs, which stands for First (byte) In, First (byte) Out
Unlike the automatic named pipes from process substitution:
FIFO takes no storage, once data is read its gone.
You control where FIFOs are created
They persist until you delete them
Any process can write to them by path (e.g., echo hi > my_pipe)
You can see them with ls and examine them like files, therefore used for complex data flow
One problem with FIFOs is that they'll "block" any operations on them until both the read side of the pipe and the write side of the pipe are ready. This provides automatic synchronization.

# Refrences
pwn.college notes